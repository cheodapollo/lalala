/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 
#include <sys/time.h>
#include "pdvsa.h"
#include "md5.h"
#include <limits.h>
/*Archivo para escribir el log de la bomba*/
FILE* log_bomba;

/*Datos sobre la bomba*/
char* nombre;
int capacidad;
int inventario;
int consumo;
int centros;
int tiempo = 0;
struct ticket pase;

/*Datos de red leidos en la entrada*/
char** dist_n; //Nombres de centros de distribucion
char** dist_h; //Hostname de centros de distribucion
int* dist_ti; // Tiempo que tarda el centro en responder
int* dist_o;
void
pdvsa_prog_1(char *host)
{
  CLIENT *clnt;
  int  *result_1;
  int  pedir_tiempos_1_arg;
  int  *result_2;
  ticket  pedir_gasolina_1_arg;
  ticket  *result_3;
  reto  validar_respuesta_1_arg;

#ifndef	DEBUG
  clnt = clnt_create (host, PDVSA_PROG, PDVSA_VERS, "udp");
  if (clnt == NULL) {
    clnt_pcreateerror (host);
    exit (1);
  }
#endif	/* DEBUG */

  result_1 = pedir_tiempos_1(&pedir_tiempos_1_arg, clnt);
  if (result_1 == (int *) NULL) {
    clnt_perror (clnt, "call failed");
  }
  result_2 = pedir_gasolina_1(&pedir_gasolina_1_arg, clnt);
  if (result_2 == (int *) NULL) {
    clnt_perror (clnt, "call failed");
  }
  result_3 = validar_respuesta_1(&validar_respuesta_1_arg, clnt);
  if (result_3 == (ticket *) NULL) {
    clnt_perror (clnt, "call failed");
  }
#ifndef	DEBUG
  clnt_destroy (clnt);
#endif	 /* DEBUG */
}



char* leer_flags(int argc, char** argv){
  int c;
  char* fichero;
  while (1) {
    int aux = 0;
    static struct option long_options[] = {
      {"cp", 1, 0, 'q'},
      {"fc", 1, 0, 'w'},
      {0, 0, 0, 0}
    };
    c = getopt_long_only(argc, argv, "n:c:i:",long_options, &aux);
    if (c == -1)
      break;

    switch (c) {
    case 'n':
      nombre =  optarg;
      break;
    case 'c':
      consumo =  atoi(optarg);
      break;
    case 'q':
      capacidad = atoi(optarg);
      break;
    case 'w':
      fichero = optarg;
      break;
    case 'i':
      inventario = atoi(optarg);
      break;      
    }
  }
  return fichero;
}
  
int num_lineas(FILE* archivo){
  int num_lineas = 0;  
  
  char *line = NULL;
  size_t len = 0;
  ssize_t read;
  
  while ((read = getline(&line, &len, archivo)) != -1) 
    num_lineas++;
  free(line);
  return num_lineas;
}

void leer_entrada(int argc, char** argv){
  if (argc != 11) {
    fprintf(stderr, "Entrada invalida, faltan flags\n");
    exit(0);
  }
  else{
    char* fichero = leer_flags(argc,argv);   
    FILE* entrada;
    if ((entrada = fopen(fichero,"r")) == NULL){
      fprintf(stderr, "%s: %s : No se pudo abrir el archivo\n", 
	      argv[0], argv[10]);
      exit(EXIT_FAILURE);
    }
    else {
      FILE* aux = fopen(fichero,"r");
      centros = num_lineas(aux);
      fclose(aux);
      dist_n = malloc(sizeof(char*)*centros);
      dist_h = malloc(sizeof(char*)*centros);
      dist_ti = malloc(sizeof(int*)*centros);
      dist_o = malloc(sizeof(int*)*centros);

      int i;
      /*Inicializar el orden*/
      for(i = 0; i < centros; i++)
	dist_o[i] = i; 

      char nombre[20];
      char host[20];


      for(i = 0; i < centros; i++){ 
	fscanf(entrada,"%[^'&']&%s\n",nombre,host);
	dist_n[i] = malloc(sizeof(char*)*strlen(nombre));
	strcpy(dist_n[i],nombre);
	dist_h[i] = malloc(sizeof(char*)*strlen(host));
	strcpy(dist_h[i],host);
      }
      fclose(entrada);
    }
  }
}

/* Funcion que se encarga de liberar memoria de los arreglos creados*/
void liberar_mem(){
  int i;
  for(i=0; i < centros; i++){
    free(dist_n[i]);
    free(dist_h[i]);
  }
  free(dist_n);
  free(dist_h);
}


/* Algoritmo de ordenamiento de mezcla */
void merge(int izq, int med, int der){
  int *aux = malloc(sizeof(int)*(der-izq));  
  int i=izq;
  int j=med;
  int k=0;

  while(i != med && j != der) {
    if (dist_ti[i] <= dist_ti[j]) {
      aux[k]=dist_o[i];
      ++i;
    }
    else if (dist_ti[j] < dist_ti[i]) {		
      aux[k]=dist_o[j];
      ++j;		
    }
    k++;
  }
  while(i != med) {
    aux[k]=dist_o[i];
    ++i;
    ++k;
  }
  while(j != der) {
    aux[k]=dist_o[j];
    ++j;
    ++k;
  }	
  k=0;
  while(k != (der-izq)) {
    dist_o[izq+k]=aux[k];
    ++k;
  }
  
  /*Libero memoria */
  free(aux);
}

/* Algoritmo de ordenamiento */ 
void ordenar_centros(int izq, int der){
  if (der - izq >= 2) {
    /*Encuentro el elemento del medio del arreglo */
    int med=((izq+der+1)/2);
    /*Ordeno la parte iquierda del arreglo */
    ordenar_centros(izq,med);
    /*Ordeno la parte derecha del arreglo*/
    ordenar_centros(med,der);
    /*Uso el algoritmo de mezcla para ordenar todo el arreglo*/
    merge(izq,med,der);
  }
}


/*Funcion que se encarga de pedir los tiempos de respuesta 
 * de los centros */
void pedir_tiempos(){

  CLIENT *clnt;
  int  *result_1 = NULL;
  int pedir_tiempos_1_arg;
  
  int i;
  for(i=0; i < centros; i++){
#ifndef	DEBUG
    clnt = clnt_create (dist_h[i], PDVSA_PROG, PDVSA_VERS, "udp");
    if (clnt == NULL) {
      clnt_pcreateerror (dist_h[i]);
      exit (1);
    }
#endif	
    result_1 = pedir_tiempos_1(&pedir_tiempos_1_arg, clnt);
    if (result_1 == (int *) NULL) {
      dist_ti[i] = INT_MAX;
      continue;
    }
    dist_ti[i] = *result_1;
#ifndef	DEBUG
    clnt_destroy (clnt);
#endif	 
  }
}

/* Funcion que se encarga de pedir gasolina al centro */  
void pedir_gasolina(){
  CLIENT *clnt;
  int  *result_1 = NULL;
  int *pedir_tiempos_1_arg = NULL;
  ticket *ticket_aux;
  int i;
  for( i=0; i < centros; i++){
#ifndef	DEBUG
    clnt = clnt_create (dist_h[i], PDVSA_PROG, PDVSA_VERS, "udp");
    if (clnt == NULL) {
      clnt_pcreateerror (dist_h[i]);
      exit (1);
    }
#endif 
    result_1 = pedir_gasolina_1(&pase, clnt);
    if (result_1 == (int *) NULL) {
      continue;
    }
    else{
    }
    /* Si el centro me puede atender */  
    if (*result_1 == (-1)){
      if(dist_ti[dist_o[i]] + tiempo <= 480){	 
	usleep(dist_ti[dist_o[i]] * 100000);
	if( consumo * dist_ti[dist_o[i]]  > inventario)
	  inventario = 38000;
	else{ 
	  inventario = inventario - (consumo * dist_ti[dist_o[i]] ); // 
	  inventario = inventario + 38000;
	}
	tiempo = tiempo + dist_ti[dist_o[i]] ;
      }    
    } 
    if (*result_1 > 0){
      struct reto reto_aux;
      char mensaje[80];
      sprintf( mensaje, "%d", *result_1 );
      unsigned *d = md5(mensaje, strlen(mensaje));
      reto_aux.respuesta = d;
      reto_aux.reto = *result_1;
      ticket_aux = validar_respuesta_1(&reto_aux, clnt);
      pase = *ticket_aux;
      pedir_gasolina();
    }  
	  
  }
}


int
main (int argc, char *argv[])
{

  char *host;
  leer_entrada(argc, argv);
  tiempo = 0;
  /*Creo el nombre del log de la bomba */
  char documento [50];  
  strcpy(documento, "log_");
  strcat(documento, nombre);
  strcat(documento, ".txt");
  log_bomba = fopen(documento,"w+");
  fprintf(log_bomba,"--------------INICIO DE SIMULACION-------------\n" ); 
  fprintf(log_bomba,"* Nombre de la bomba: %s\n",nombre);
  fprintf(log_bomba,"* Capacidad maxima de la bomba: %d\n",capacidad); 
  fprintf(log_bomba,"* Inventario de la bomba: %d\n",inventario);
  fprintf(log_bomba,"* Consumo de la bomba: %d\n",consumo); 
  int i;
  pase.ip_centro = 0;
  for(i = 0; i < centros; i++){
    printf("Nombre Centro : %s\n",dist_n[i]);
    printf("Host  Centro : %s\n",dist_h[i]);
  }

  while(tiempo <= 480){	  
    int unsleep;
    /* Se piden los tiempos de los centros cada ves que pasa un minuto */
    pedir_tiempos();
    ordenar_centros(0,centros);
    usleep (100000);

    /* Caso de que el consumo es mayor al inventario actual */
    if( inventario - consumo  <= 0){
      inventario = 0;
      fprintf(log_bomba,"Evento en el tiempo %d:\n\tEl tanque de la bomba se encuentra vacio\n",tiempo);
    }  

    /* Caso en el que el inventario es mayor al consumo */
    if( inventario >= consumo)
      inventario = inventario - consumo;

    /* Caso de que pueda pedir una gandola la bomba */
    if ( capacidad - inventario >= 38000  ){
      int invactual = inventario;
      pedir_gasolina();
      fprintf(log_bomba,"Evento en el tiempo %d:\n\tLa bomba pide gasolina utilizando el ticket:\n\t\t | TicketNo. %d | IP: 159.90.9.%d | Tiempo: %d |\n",tiempo,pase.numero,pase.ip_centro,pase.hora);

      if( invactual == inventario){
        fprintf(log_bomba,"Evento en el tiempo %d:\n\tLa bomba no puede ser atendida\n",tiempo);
	fprintf(log_bomba,"\tInventario actual de la bomba: %d\n",inventario);
      }
    }

    //    fprintf(log_bomba,"%d %s",tiempo,"min \n");
    // fprintf(log_bomba,"* Inventario actual de la bomba: %d\n",inventario);
    printf("EL inventario es: %d \n",inventario);
    printf("El tiempo es: %d \n",tiempo);
    tiempo++;
  }

}
